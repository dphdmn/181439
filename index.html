<!DOCTYPE html>
<html>

<head>
    <title>181439</title>
    <style>
        body {
            color: white;
            font-family: Calibri;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #2c2c2c;
        }

        .container {
            text-align: center;
            border: 2px solid;
            border-radius: 10px;
            padding: 20px 30px;
            background-color: #202020;
            box-shadow: 0 8px 8px rgba(0, 255, 255, 2);
            position: absolute;
            top: 150px;
        }

        .information {
            position: absolute;
            top: 150px;
            min-width: 400px;
            /* Adjust the initial top position */
            left: 1350px;
            /* Adjust the initial left position */
            text-align: center;
            border: 2px solid;
            border-radius: 10px;
            padding: 20px 30px;
            background-color: #202020;
            box-shadow: 0 8px 8px rgba(0, 255, 255, 2);
        }

        #tipinfo {
            font-size: 15px;
            color: gray;
        }

        .header {
            text-align: center;
            cursor: grab;
            padding: 12px 24px;
            font-size: 30px;
            color: #ffffff;
            background-color: #1a1a1a;
            box-shadow: 0px 4px 4px rgba(255, 255, 255, 0.7);
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            color: white;
            font-weight: bold;
            webkit-user-select: none;
            /* Chrome, Safari, Opera */
            -moz-user-select: none;
            /* Firefox */
            -ms-user-select: none;
            /* IE/Edge */
            user-select: none;
            /* Generic */
        }

        .grid-container {
            width: 400px;
            height: 400px;
            font-size: 80px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 1px;
            margin: 30px;
            border: 0;
        }

        .container-CB {
            margin-top: 20px;
            font-size: 20px;
        }

        .grid-element {
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            width: 100%;
            height: 100%;
            border: 1px solid black;
            -webkit-user-select: none;
            /* Chrome, Safari, Opera */
            -moz-user-select: none;
            /* Firefox */
            -ms-user-select: none;
            /* IE/Edge */
            user-select: none;
            /* Generic */
            color: black;
        }

        #moves {
            font-size: 50px;
            min-height: 125px;
            display: flex;
            align-items: center;
            justify-content: center;
            vertical-align: center;
        }

        #scramblesLeft {
            font-size: 30px;
        }

        #scramblesDone {
            font-size: 30px;
        }

        #actuallyDone {
            font-size: 20px;
        }

        #finishedBad {
            font-size: 20px;
        }

        #skips {
            font-size: 20px;
        }

        .red {
            background-color: #fb6364;
        }

        .yellow {
            background-color: #eeff55;
        }

        .green {
            background-color: #6fff8c;
        }

        .light-blue {
            background-color: #89dcff;
        }

        .empty-tle {
            color: #202020;
            border: 0;
        }

        .neutralMoves {
            color: white;
        }

        .numbers {
            color: #00FFFF;
        }

        .goodMoves {
            color: green;
        }

        .badMoves {
            color: red;
        }

        /* Base styles for the button */
        button {
            padding: 12px 24px;
            font-size: 16px;
            color: #ffffff;
            background-color: #1a1a1a;
            box-shadow: 0 2px 4px rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        /* Fancy and unique hover effect */
        button:hover {
            transform: translateY(-2px);
            background-color: #555555;
        }

        /* Fancy and unique active effect */
        button:active {
            transform: translateY(2px);
            background-color: #111111;
        }

        /* Fancy and unique focus effect */
        button:focus {
            outline: none;
            box-shadow: 0 0 0 2px #ffffff, 0 0 0 4px #555555;
        }

        /* Hide the default checkbox */
        input[type="checkbox"] {
            position: absolute;
            opacity: 0;
        }

        /* Style the custom checkbox container */
        label {
            position: relative;
            padding-left: 30px;
            cursor: pointer;
            color: #fff;
        }

        /* Create the checkbox shape */
        label::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 20px;
            height: 20px;
            border: 2px solid #fff;
            background-color: transparent;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        /* Style the custom checkmark when checked */
        input[type="checkbox"]:checked+label::before {
            background-color: #fff;
            transform: rotate(-45deg);
            border-color: #00FFFF;
            border-left: none;
            border-top: none;
        }

        /* Add a cool animation to the checkmark */
        label::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 4px;
            width: 6px;
            height: 12px;
            border: 2px solid #00FFFF;
            border-top: none;
            border-right: none;
            transform: translateY(-50%) rotate(-45deg);
            opacity: 0;
            transition: all 0.2s ease;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">Puzzle<br><span id="tipinfo">(you can move this window)<br>Resize puzzle with PageUp and
                PageDown keys!</span></div>
        <div class="grid-container" id="gridContainer">
            <!-- Grid elements will be generated here -->
        </div>
    </div>
    <div class="information">
        <div class="header">Information<br><span id="tipinfo">(you can move this window)</span></div>
        <p id="moves">0</p>
        <p id="scramblesLeft"></p>
        <p id="scramblesDone"></p>
        <p id="actuallyDone"></p>
        <p id="finishedBad"></p>
        <p id="skips"></p>
        <button id="saveButton">Save to File</button>
        <input type="file" id="loadButton" accept=".txt" style="display: none;">
        <button onclick="document.getElementById('loadButton').click()">Load from File</button>
        <br>

        <div class="container-CB">
            <input type="checkbox" id="myCheckbox" checked="True">
            <label id="cblabel" for="myCheckbox">Mouse control enabled</label>
        </div>
    </div>
    <script src="json.js"></script>
    <script>
        const container = document.querySelector('.container');
        const checkbox = document.getElementById('myCheckbox');
        const cblabel = document.getElementById('cblabel');
        function loadCheckboxState() {
            const savedState = localStorage.getItem('checkboxState');
            if (savedState !== null) {
                if (savedState === 'true') {
                    checkbox.checked = true;
                    cblabel.innerHTML = "Mouse control enabled";
                } else {
                    checkbox.checked = false;
                    cblabel.innerHTML = "Mouse control disabled";
                }
            }
        }
        loadCheckboxState();
        checkbox.addEventListener('change', function () {
            localStorage.setItem('checkboxState', checkbox.checked);
            if (this.checked) {
                cblabel.innerHTML = "Mouse control enabled";
            } else {
                cblabel.innerHTML = "Mouse control disabled";
            }
        });
        function debug() {
            scramblesList = scramblesList.slice(175000, 175005);
        }

        function wrapTextWithSpan(text, classname) {
            return "<span class=\"" + classname + "\">" + text + "</span>";
        }
        document.getElementById("loadButton").addEventListener("change", (event) => {
            cntrlPressed = true;
            const fileInput = event.target;
            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                const reader = new FileReader();

                reader.onload = (e) => {
                    const loadedContent = e.target.result;
                    loadgame(loadedContent);
                    setTimeout(function () {
                        cntrlPressed = false;
                    }, 1000);

                };

                reader.readAsText(file);
            }
        });

        document.getElementById("saveButton").addEventListener("click", () => {
            const myString = savegame();
            const filename = "saveFile_egg.txt";
            const blob = new Blob([myString], {
                type: "text/plain"
            });
            const url = URL.createObjectURL(blob);
            const anchor = document.createElement("a");
            anchor.href = url;
            anchor.download = filename;
            anchor.click();
            URL.revokeObjectURL(url);
            document.activeElement.blur();
        });

        const movesDisplayElement = document.getElementById('moves');
        const scramblesLeftDisplayElement = document.getElementById('scramblesLeft');
        const scramblesDoneDisplayElement = document.getElementById('scramblesDone');
        const scramblesActuallyDoneDisplayElement = document.getElementById('actuallyDone');
        const finishedBadDisplayElement = document.getElementById('finishedBad');
        const skipsDisplayElement = document.getElementById('skips');
        const fileInput = document.getElementById('loadButton');
        var scramblesList = JSON.parse(myjson);
        updateScrLength();
        var cntrlPressed = false;
        var currentState = '';
        var nowSolving = false;
        var currentMoves = 0;
        var currentOpt = 0;
        var finishedBad = 0;
        var skips = 0;
        var actuallyDoneAmount = 0;
        var randItem;
        var scramblesToRemove = [];
        scramblesActuallyDoneDisplayElement.innerHTML = "Actually done (full scrambles only): " + wrapTextWithSpan(actuallyDoneAmount.toString(), "numbers");
        finishedBadDisplayElement.innerHTML = "Fails (finished, not optimal): " + wrapTextWithSpan(finishedBad.toString(), "numbers");
        skipsDisplayElement.innerHTML = "Skips (spacebar while solving): " + wrapTextWithSpan(skips.toString(), "numbers");
        // Function to initialize the grid with the default state
        function savegame() {
            return btoa(JSON.stringify([scramblesList, finishedBad, actuallyDoneAmount, skips]));
        }

        function loadgame(mystring) {
            const data = JSON.parse(atob(mystring));
            scramblesList = data[0];
            updateScrLength();
            finishedBad = data[1];
            actuallyDoneAmount = data[2];
            skips = data[3]
            scramblesActuallyDoneDisplayElement.innerHTML = "Actually done (full scrambles only): " + wrapTextWithSpan(actuallyDoneAmount.toString(), "numbers");
            finishedBadDisplayElement.innerHTML = "Fails (finished, not optimal): " + wrapTextWithSpan(finishedBad.toString(), "numbers");
            skipsDisplayElement.innerHTML = "Skips (spacebar while solving): " + wrapTextWithSpan(skips.toString(), "numbers");
            nowSolving = false;
            initializeGrid();
            fileInput.value = null;
        }

        function getRandomItem(list) {
            const randomIndex = Math.floor(Math.random() * list.length);
            return list[randomIndex];
        }

        function updateScrLength() {
            var scL = scramblesList.length;
            var scDone = 181439 - scramblesList.length;
            var precentage = scDone * 100 / 181439;
            scramblesLeftDisplayElement.innerHTML = "Scrambles left: " + scL.toString();
            scramblesDoneDisplayElement.innerHTML = "Scrambles done: " + scDone.toString() + " (" + wrapTextWithSpan(precentage.toFixed(3), "numbers") + "%)";
        }

        function initializeGrid() {
            container.style.boxShadow = '0 8px 8px rgba(0, 255, 255, 2)';
            if (document.activeElement) {
                document.activeElement.blur();
            }
            scramblesToRemove.length = 0;
            movesDisplayElement.classList = 'neutralMoves';
            if (scramblesList.length === 0) {
                movesDisplayElement.innerHTML = "<img src=\"https://cdn.discordapp.com/emojis/890730587462185012.webp\"></img>I Love Egg!<img src=\"https://cdn.discordapp.com/emojis/890730587462185012.webp\"></img>";
                container.style.boxShadow = '0 100px 1000px rgba(255, 255, 0, 10)';
                document.body.style.backgroundColor = 'white';
            } else {
                if (scramblesList.length === 1) {
                    randItem = scramblesList[0];
                } else {
                    while (typeof randItem === 'undefined' || randItem['s'] === currentState) {
                        randItem = getRandomItem(scramblesList);
                    }
                }
                currentState = randItem['s'];
                currentOpt = randItem['m']
                scramblesToRemove.push(currentState);
                nowSolving = true;
                currentMoves = 0;
                movesDisplayElement.innerHTML = 0;
                applyGridState();
            }
        }

        function convertScramble() {
            return document.getElementById('gridContainer').innerHTML.replace(/[^\d]/g, '').split('').join(' ').replace(/(.*)( .*)/, '$1$2').replace(/^(.{5})(.)(.{5})(.)/, '$1/$3/');
        }

        function updatePuzzleInfo() {
            if (nowSolving) {
                currentMoves += 1;
                movesDisplayElement.innerHTML = currentMoves;

                if (document.getElementById('gridContainer').innerHTML.replace(/[^\d]/g, '') === '123456780') {
                    nowSolving = false;
                    if (currentMoves.toString() === currentOpt) {
                        var before = scramblesList.length;
                        scramblesToRemove.forEach(function (item) {
                            scramblesList = scramblesList.filter(egg => egg['s'] !== item);
                        });
                        updateScrLength();
                        movesDisplayElement.innerHTML += "<br>(- " + (before - scramblesList.length).toString() + " scrambles!)";
                        movesDisplayElement.classList = 'goodMoves';
                        container.style.boxShadow = '0px 16px 16px rgba(0, 255, 0, 8)';
                        actuallyDoneAmount += 1;
                        scramblesActuallyDoneDisplayElement.innerHTML = "Actually done (full scrambles only): " + wrapTextWithSpan(actuallyDoneAmount.toString(), "numbers");
                    } else {
                        console.log("WRONG, opt was " + currentOpt.toString() + " scr: " + currentState);
                        movesDisplayElement.innerHTML += "<br>(not optimal)";
                        movesDisplayElement.classList = 'badMoves';
                        container.style.boxShadow = '0 16px 16px rgba(255, 0, 0, 10)';
                        finishedBad += 1;
                        finishedBadDisplayElement.innerHTML = "Fails (finished, not optimal): " + wrapTextWithSpan(finishedBad.toString(), "numbers");
                    }
                    scramblesToRemove.length = 0;
                } else {
                    var curScr = convertScramble();
                    if (scramblesToRemove.includes(curScr)){
                        movesDisplayElement.innerHTML += "<br>you failed, skip!";
                        container.style.boxShadow = '0 16px 16px rgba(255, 0, 0, 10)';
                        movesDisplayElement.classList = 'badMoves';
                    }
                    scramblesToRemove.push(curScr);
                }
            }
        }

        const allowedIndexes = {
            0: [1, 3],
            1: [0, 2, 4],
            2: [1, 5],
            3: [0, 4, 6],
            4: [1, 3, 5, 7],
            5: [2, 4, 8],
            6: [3, 7],
            7: [4, 6, 8],
            8: [5, 7]
        };
        //lineral coordinats to X (0..N^2-1) to (0..N-1)
        function linToX(lin) {
            let N = 3;
            return (lin) % N;
        }

        //lineral coordinats to Y (0..N^2-1) to (0..N-1)
        function linToY(lin) {
            let N = 3;
            return parseInt((Math.floor((lin) / N)));
        }
        //X Y coords to lin (0..N-1) (0..N-1) to (0..N^2-1
        function XYtolin(X, Y) {
            let N = 3;
            return Y * N + X;
        }

        function isHoveredIndexAllowed(zeroIndex, hoveredIndex) {
            const allowedIndexesArray = allowedIndexes[zeroIndex];
            if (allowedIndexesArray) {
                return allowedIndexesArray.includes(hoveredIndex);
            }
            return false;
        }
        // Function to swap 0 with the hovered tile
        function performMove(zeroIndex, hoveredIndex) {
            if (zeroIndex != hoveredIndex) {
                if (isHoveredIndexAllowed(zeroIndex, hoveredIndex)) {
                    // Swap numbers and classes

                    const gridElements = document.getElementsByClassName('grid-element');
                    const tempNum = gridElements[hoveredIndex].textContent;
                    const tempClass = gridElements[hoveredIndex].className;

                    gridElements[hoveredIndex].textContent = '0';
                    gridElements[hoveredIndex].className = gridElements[zeroIndex].className;
                    gridElements[zeroIndex].textContent = tempNum;
                    gridElements[zeroIndex].className = tempClass;
                    updatePuzzleInfo();
                } else {
                    if (linToX(zeroIndex) === linToX(hoveredIndex)) {
                        //same vertical 
                        Yzero = linToY(zeroIndex);
                        Yhover = linToY(hoveredIndex);
                        if (Yhover > Yzero) {
                            performMove(zeroIndex, XYtolin(linToX(hoveredIndex), Yhover - 1));
                            performMove(XYtolin(linToX(hoveredIndex), Yhover - 1), hoveredIndex);
                        } else {
                            performMove(zeroIndex, XYtolin(linToX(hoveredIndex), Yhover + 1));
                            performMove(XYtolin(linToX(hoveredIndex), Yhover + 1), hoveredIndex);
                        }
                    }
                    if (linToY(zeroIndex) === linToY(hoveredIndex)) {
                        //same horizontal
                        Xzero = linToX(zeroIndex);
                        Xhover = linToX(hoveredIndex);
                        if (Xhover > Xzero) {
                            performMove(zeroIndex, XYtolin(linToX(hoveredIndex) - 1, linToY(hoveredIndex)));
                            performMove(XYtolin(linToX(hoveredIndex) - 1, linToY(hoveredIndex)), hoveredIndex);
                        } else {
                            performMove(zeroIndex, XYtolin(linToX(hoveredIndex) + 1, linToY(hoveredIndex)));
                            performMove(XYtolin(linToX(hoveredIndex) + 1, linToY(hoveredIndex)), hoveredIndex);
                        }
                    }
                }
            }
        }

        function swapTiles(hoveredElement) {
            const gridElements = document.getElementsByClassName('grid-element');
            const zeroIndex = Array.from(gridElements).findIndex((element) => element.textContent === '0');
            const hoveredIndex = Array.from(gridElements).indexOf(hoveredElement);
            performMove(zeroIndex, hoveredIndex);
        }

        // Function to apply the grid state
        function applyGridState() {
            const inputString = currentState;
            const gridNumbers = inputString.split('/');
            const gridContainer = document.getElementById('gridContainer');

            gridContainer.innerHTML = '';

            for (let i = 0; i < gridNumbers.length; i++) {
                const rowNumbers = gridNumbers[i].trim().split(' ');
                for (let j = 0; j < rowNumbers.length; j++) {
                    const num = rowNumbers[j].trim();
                    const gridElement = document.createElement('div');
                    gridElement.textContent = num;
                    gridElement.classList.add('grid-element');

                    if (num === '1' || num === '2' || num === '3') {
                        gridElement.classList.add('red');
                    } else if (num === '4' || num === '7') {
                        gridElement.classList.add('yellow');
                    } else if (num === '5' || num === '6') {
                        gridElement.classList.add('green');
                    } else if (num === '8') {
                        gridElement.classList.add('light-blue');
                    } else if (num === '0') {
                        gridElement.classList.add('empty-tle');
                    }

                    gridElement.addEventListener('mouseover', function () {
                        if (!cntrlPressed && checkbox.checked && !game_isDragging && !isDragging) {
                            swapTiles(this);
                        }
                    });

                    gridContainer.appendChild(gridElement);
                }
            }
        }

        const zeroIndexList = [{
            r: -1,
            l: 1,
            u: 3,
            d: -1
        },
        {
            r: 0,
            l: 2,
            u: 4,
            d: -1
        },
        {
            r: 1,
            l: -1,
            u: 5,
            d: -1
        },
        {
            r: -1,
            l: 4,
            u: 6,
            d: 0
        },
        {
            r: 3,
            l: 5,
            u: 7,
            d: 1
        },
        {
            r: 4,
            l: -1,
            u: 8,
            d: 2
        },
        {
            r: -1,
            l: 7,
            u: -1,
            d: 3
        },
        {
            r: 6,
            l: 8,
            u: -1,
            d: 4
        },
        {
            r: 7,
            l: -1,
            u: -1,
            d: 5
        }
        ];

        function findZeroIndex() {
            return Array.from(document.getElementsByClassName('grid-element')).findIndex((element) => element.textContent === '0');
        }
        document.addEventListener('keydown', function (event) {
            if (event.ctrlKey) {
                cntrlPressed = true;
            }
            var mykey = event.key.toLowerCase();
            //console.log(mykey);
            const dphKeys = str => str.replace(/arrowright|arrowleft|arrowup|arrowdown/g, key => ({
                arrowright: 'r',
                arrowleft: 'l',
                arrowup: 'u',
                arrowdown: 'd'
            }[key]));
            const benKeys = str => str.replace(/f|j|i|k/g, key => ({
                f: 'r',
                j: 'l',
                i: 'u',
                k: 'd'
            }[key]));
            mykey = dphKeys(mykey);
            mykey = benKeys(mykey);
            if (/^[rlud]$/i.test(mykey)) {
                var zeroIndex = findZeroIndex();
                var hoveredElement = zeroIndexList[zeroIndex][mykey];
                if (hoveredElement != -1) {
                    performMove(zeroIndex, zeroIndexList[zeroIndex][mykey]);
                }
            }
            // Check if the pressed key is the spacebar (key code 32)
            if (event.keyCode === 32) {
                // Perform your action here, for example, display an alert
                if (nowSolving) {
                    skips += 1;
                    skipsDisplayElement.innerHTML = "Skips (spacebar while solving): " + wrapTextWithSpan(skips.toString(), "numbers");
                }
                initializeGrid();
                
            }
        });
        document.addEventListener('keyup', function (event) {
            if (event.key === 'Control') {
                cntrlPressed = false;
            }
        });
        // Initialize the grid with the default state
        initializeGrid();

// JavaScript to make the floating window draggable
        let isDragging = false;
        let offsetX = 0;
        let offsetY = 0;

        const information = document.querySelector('.information');
        const header = information.querySelector('.header');

        header.addEventListener('mousedown', (e) => {
            isDragging = true;
            offsetX = e.clientX - information.offsetLeft;
            offsetY = e.clientY - information.offsetTop;
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                // Calculate the new position of the window
                const left = e.clientX - offsetX;
                const top = e.clientY - offsetY;

                // Get the boundaries of the visible area
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;

                // Restrict the movement within the boundaries of the screen
                const maxLeft = screenWidth - information.offsetWidth;
                const maxTop = screenHeight - information.offsetHeight;

                // Ensure the window stays within the screen boundaries
                const newLeft = Math.min(Math.max(0, left), maxLeft);
                const newTop = Math.min(Math.max(0, top), maxTop);

                // Apply the new position to the window
                information.style.left = newLeft + 'px';
                information.style.top = newTop + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });


// JavaScript to make the floating window draggable
        let game_isDragging = false;
        let game_offsetX = 0;
        let game_offsetY = 0;

        const game_information = document.querySelector('.container');
        const game_header = game_information.querySelector('.header');

        game_header.addEventListener('mousedown', (e) => {
            game_isDragging = true;
            game_offsetX = e.clientX - game_information.offsetLeft;
            game_offsetY = e.clientY - game_information.offsetTop;
        });

        document.addEventListener('mousemove', (e) => {
            if (game_isDragging) {
                // Calculate the new position of the window
                const left = e.clientX - game_offsetX;
                const top = e.clientY - game_offsetY;

                // Get the boundaries of the visible area
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;

                // Restrict the movement within the boundaries of the screen
                const maxLeft = screenWidth - game_information.offsetWidth;
                const maxTop = screenHeight - game_information.offsetHeight;

                // Ensure the window stays within the screen boundaries
                const newLeft = Math.min(Math.max(0, left), maxLeft);
                const newTop = Math.min(Math.max(0, top), maxTop);

                // Apply the new position to the window
                game_information.style.left = newLeft + 'px';
                game_information.style.top = newTop + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            game_isDragging = false;
        });

        document.addEventListener("keydown", function (event) {
            const gridContainer = document.querySelector(".grid-container");
            const computedStyle = window.getComputedStyle(gridContainer);

            const currentWidth = parseInt(computedStyle.width);
            const currentHeight = parseInt(computedStyle.height);
            const currentFontSize = parseInt(computedStyle.fontSize);

            let widthChange = 0;
            let heightChange = 0;
            let fontSizeChange = 0;
            if (event.key === "PageUp") {
                if (currentWidth < 710) {
                    widthChange = 10;
                    heightChange = 10;
                    fontSizeChange = 2;
                } else {
                    return;
                }
            } else if (event.key === "PageDown") {
                if (currentWidth > 160) {
                    widthChange = -10;
                    heightChange = -10;
                    fontSizeChange = -2;
                } else {
                    return;
                }
            } else {
                return; // Exit early if any other key is pressed
            }

            gridContainer.style.width = currentWidth + widthChange + "px";
            gridContainer.style.height = currentHeight + heightChange + "px";
            gridContainer.style.fontSize = currentFontSize + fontSizeChange + "px";
        });
    </script>
</body>

</html>